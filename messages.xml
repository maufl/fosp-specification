<?xml version="1.0" encoding="UTF-8"?>
<section anchor="messages" title="Messages">
  <t>Messages are the basic unit of communication in the FOSP network.
  There are three different types of messages which serve different purposes.
  How a message is serialized depends on the protocol that is used to transport the message.
  </t>
  <section anchor="msg-type" title="Types">
    <t>Each message has a specific type, which determines the kind of purpose this message serves.
    The type is implicitly given in the way that the content of the message determines it’s type.
    For now there are only three types of messages needed to support all functionality.
    The types are requests, responses and notifications.
    Should there be the need for additional types of messages, a new one can be added in later versions of the protocol.
    </t>
    <t>All messages can have headers and a body, similar to HTTP messages and are distinguished by their main attributes.
    Requests and notifications usually act on, or are emitted from an object or an attachemnt.
    The identifier of the object or attachemnt is then part of the request.
    If a request does not act upon an object, the identifier is replaced with an asterisk.
    </t>
  </section>
  <section anchor="msg-type-request" title="Request">
    <t>Requests are sent from clients to servers to authenticate or manipulate objects.
    A request consists of ...
    <list>
      <t>a request type</t>
      <t>optionally an identifier of a resource that it manipulates</t>
    </list>
    The content of the body depends on the type of request.
    For example, the body of a GET or DELETE request is empty and the body of a CREATE request contains the new object.
    In general the body is a JSON object, except for the WRITE request that has the byte representation of the file as the body.
    </t>
    <t>The request types are described in the following section.</t>
    <section anchor="msg-type-request-info" title="Info">
      <t>TODO</t>
    </section>
    <section anchor="msg-type-request-bind" title="Bind">
      <t>The BIND request is used to authenticate the client.
      The body MUST contain an object with the "method" attribute that specifies the used authentication method.
      The possible methods of authentication are not final yet, however every server SHOULD support a simple authentication by name and password.
      In this case the object also contains a "user" and "password" attribute containing the full user name and the password.
      </t>
      <t>
      The server verifies that the authentication is successfull and sents a success response or a failed response otherwise.
      All future request will then be made in the name of this authenticated user.
      How the state is kept depends on the transport protocol used.
      It can for example either be a tied to network connection, or be a cookie supplied in each request.
      </t>
    </section>
    <section anchor="msg-type-request-get" title="Get">
      <t>The GET request is used to retrieve an object.
      The resource identifier in the request denotes the object that should be returned.
      The server MUST ignore any content in the body of the request.
      </t>
      <t>The server will first check the rights of the current user on this object.
      Then it might either sent a response with an status that indicates an error or it might sent a success response that contains the requested object in its body.
      Even when the request was successfull, not the whole object might be returned because the user might have the right to read some fields but not others.
      </t>
    </section>
    <section anchor="msg-type-request-list" title="List">
      <t>The LIST request is used to discover all child objects of a certain object.
      The resource identifier specifies the object of which the children should be returned.
      </t>
      <t>If successfull, the response will contain an array of names of the child objects.
      </t>
    </section>
    <section anchor="msg-type-request-create" title="Create">
      <t>The CREATE request is used to store new objects on the server.
      The resource identifier is the desired location for the new object.
      The body containes the object to store.
      </t>
      <t>The server will try to store the object at the given location but MUST first check whether the user has sufficent rights and an object with the given identifier does not yet exist.
      When the server can store the object, it will return a success response and an failed response otherwise.
      </t>
    </section>
    <section anchor="mgs-type-request-patch" title="Patch">
      <t>The PATCH request is used to update an already existing object on the server.
      The resource identifier specifies the object that should be updated.
      The body containes an object with the differences that should be applied to the object.
      </t>
      <t>After checking permissions and the existence of the object, the server will apply the differences to the object.
      If successfull, a succeeded message is returned or an failed message otherwise.
      </t>
      <t>The differences are merged into the object as follows.
      If the original object does not have an attribute the differences object has, the attribute is copied to the object.
      If the original object already has an attribute the differences object has and the new value is <em>null</em>, the attribute is deleted from the object.
      If the original object already has an attribute the differences object has and the value is not null, the attribute is replaced with the new attribute except when the value of the old and the new attribute are both an object.
      In this case the merging is done on the attribute recursivly as it is on the whole object.
      </t>
    </section>
    <section anchor="msg-type-request-delete" title="Delete">
      <t>The DELETE request is used to remove an object from a tree.
      The resource identifier specifies the object that should be removed.
      </t>
      <t>After checking existence of the object and permissions, the server will remove the object.
      If successfull, a succeeded message is returned and a failed message otherwise.
      </t>
    </section>
    <section anchor="msg-type-request-read" title="Read">
      <t>The READ request is used to read the attachment.
      The resource identifier specifies the object of which the attachment should be read.
      </t>
      <t>The success response will contain the raw bytes of the attachment.
      </t>
    </section>
    <section anchor="msg-type-request-write" title="Write">
      <t>The WRITE request is used to write to the attachment.
      The resource identifier specifies the object of which the attachment should be written.
      The body contains the raw bytes of the attachment.
      </t>
      <t>The success response is empty.
      </t>
    </section>
  </section>
  <section anchor="msg-type-response" title="Response">
    <t>Responses are sent from servers to clients when a request has been processed.
    A response has ...
    <list>
      <t>a type, either “SUCCEEDED” or “FAILED”.</t>
      <t>a status code, an integer greater zero.</t>
      <t>a sequence number which must match the sequence number of the request
      it responds to.
      </t>
    </list>
    The body of a response depends on the request that is answered.
    For a CREATE or DELETE request it would be empty, for a SELECT request it would be the object that was requested.
    In case of a READ request it would contain the file.
    </t>
  </section>
  <section anchor="msg-type-notification" title="Notification">
    <t>Notifications are sent from servers to clients when objects change and the client
    has subscribed to those changes. A notification consists of ...
    <list>
      <t>an event which is one of “CREATED”, “UPDATED” or “DELETED”.</t>
      <t>a resource identifier.</t>
    </list>
    The notifications are sent when a request triggers an event, for example CREATE triggers a CREATED event.
    If the event equals DELETED then the body of the notification must be empty.
    Otherwise it should contain the new version of the object.
    </t>
  </section>
  <section anchor="msg-format" title="Format">
    <t>**WARNING: To simplify the definition for the moment, only ASCII characters are used.
    This WILL change as the protocol itself mandates the use of Unicode and the UTF-8 encoding and international user and resource names MUST be supported**
    </t>
    <t>Also the header definition will be subject to change after determining acceptable characters.
    For the resource identifier, we will probably refer to the IRI definition in the future.
    </t>
    <?rfc include="fig-message-abnf.xml"?>
  </section>
  <section anchor="msg-serialization" title="Serialization">
    <t>Messages are serialized into a blob of bytes.
    Most of the message is text in UTF-8 encoding, only the body is either a valid JSON object, UTF-8 encoded, or not interpreted at all.
    The second case occurs when an attached file is up- or downloaded.
    The beginning and end, e.
    g.
    the length of a message must be determined from lenght of the WebSocket message.
    </t>
  </section>
</section>
